## Array

Leetcode Link: https://leetcode.com/tag/array/

### 1) two sum

- Brute force, use two loops, get O(n2) time complexity and O(1) space complexity 

- Use hash map, get O(n) time complexity and O(n) space complexity

- ```python
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          hashmap = {}
          for i in range(len(nums)):
              hashmap[nums[i]] = i
          for i in range(len(nums)):
              complement = target - nums[i]
              if complement in hashmap and hashmap[complement] != i:
                  return [i, hashmap[complement]] 
  --------------------------------------------------------------------------
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          hashmap = {}
          for i in range(len(nums)):
              complement = target - nums[i]
              if complement in hashmap:
                  return [i, hashmap[complement]]
              hashmap[nums[i]] = i
  ```

### 2) Two sum with input array sorted

- set i and j from the begin and the last, and move towards mid

  ```python
  class Solution:
      def twoSum(self, numbers: List[int], target: int) -> List[int]:
          i = 0
          j = len(numbers) - 1
          while i < j:
              val = numbers[i] + numbers[j]
              if val == target:
                  return [i+1, j+1]
              elif val < target:
                  i += 1
              else:
                  j -= 1
          return -1
  ```

  

### 3) Three sum

- ```python
  class Solution:
      def threeSum(self, nums: List[int]) -> List[List[int]]:
          res = []
          nums.sort()
          for i,a in enumerate(nums):
              if i >0 and nums[i] == nums[i-1]:
                  continue
              l,r = i+1,len(nums)-1
              while l<r:
                  tsum = a+nums[l]+nums[r]
                  if tsum > 0:
                      r -=1
                  elif tsum < 0:
                      l += 1
                  else:
                      res.append([a,nums[l],nums[r]])
                      l += 1
                      while nums[l] == nums[l -1] and l<r:
                          l +=1
          return res
  ```

  

### 3) Remove duplicate

- ```python
  #use double pointer 
      def removeDuplicates(self, nums: List[int]) -> int:
          input = 0
          output = 0
          value = None
      
          while input < len(nums):
              if value is not None and value == nums[input]:
                  input += 1
                  continue
              nums[output] = nums[input]
              value = nums[input]
              input += 1
              output += 1
              
          return output
  class Solution:
      def removeDuplicates(self, nums: List[int]) -> int:
          index = 1
          for i in range(1,len(nums)):
              if(nums[i-1]!=nums[i]):
                  nums[index] = nums[i]
                  index+=1
          return index
  ```

  

### 4) max water container

- ```python
  class Solution:
      def maxArea(self, height: List[int]) -> int:
          res = 0
          l,r = 0,len(height) -1
          while l < r:
              area = (r - l)*min(height[l],height[r])
              res = max(area,res)
              if height[l] < height[r]:
                  l += 1
              else:
                  r -= 1
          return res
  ```

  

### 5) Permutations

- ```python
  #recursive permutations
  class Solution:
      def permute(self, nums: List[int]) -> List[List[int]]:
          result = []
          if len(nums) == 1:
              return [nums[:]]
          for i in range(len(nums)):
              n = nums.pop(0)
              perms = self.permute(nums)
              for perm in perms:
                  perm.append(n)
              result.extend(perms)
              nums.append(n)
          return result
        
  #  permutation II      
  class Solution:
      def permuteUnique(self, nums: List[int]) -> List[List[int]]:
          res = []
          perm = []
          cnt = {n:0 for n in nums}
          for n in nums:
              cnt[n] += 1
          def pmt():
              if len(perm) == len(nums):
                  res.append(perm[:])
                  return
              for n in cnt:
                  if cnt[n] > 0:
                      perm.append(n)
                      cnt[n] -= 1
                      pmt()
                      cnt[n] += 1
                      perm.pop()
          pmt()
          return res
  
  #first we are finding the next permutation
  class Solution:
      def nextPermutation(self, nums: List[int]) -> None:
          """
          Do not return anything, modify nums in-place instead.
          
          i = len(nums) - 1
          while i >0 :
              if nums[i] <= nums[i-1]:
                  i -= 1
              else:
                  break
          if i == 0:
              nums.reverse()
          nums[i],nums[i-1] = nums[i-1],nums[i]
          nums[i:].sort()
          """
          
          i = j = len(nums)-1
          while i > 0 and nums[i-1] >= nums[i]:
              i -= 1
          if i == 0:
              nums.reverse()
              return 
          while nums[j] <= nums[i-1]:
              j -= 1
          nums[i-1], nums[j] = nums[j], nums[i-1]
          nums[i:]= nums[len(nums)-1:i-1:-1]
  ```

  ### 5ï¼‰Rotation
  
  ![image-20210815093849456](/Users/manqiuliu/Library/Application Support/typora-user-images/image-20210815093849456.png)
  
  - we are doing it inplace, and the way to avoid too many temp var is to inplace in the other direction
  
  - ```python
    class Solution:
        def rotate(self, matrix: List[List[int]]) -> None:
            """
            Do not return anything, modify matrix in-place instead.
            """
            l,r = 0,len(matrix) - 1
            while l < r:
                for i in range(r - l):
                    top,bottom = l,r
                    topleft = matrix[top][l+i]
                    matrix[top][l+i] = matrix[bottom - i][l]
                    matrix[bottom - i][l] = matrix[bottom][r - i]
                    matrix[bottom][r - i] = matrix[top+i][r]
                    matrix[top+i][r] = topleft
                r -= 1
                l += 1
    ```
  
    

### 6) Spiral matrix I and II

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        oplist = []
        l,r = 0,len(matrix[0])
        t,b = 0,len(matrix)
        while l < r and t < b:
            for i in range(l,r):
                oplist.append(matrix[t][i])
            t += 1
            
            for i in range(t,b):
                oplist.append(matrix[i][r-1])
            r -= 1
            if not (l<r and t<b):
                break
                
            for i in range(r-1,l-1,-1):
                oplist.append(matrix[b-1][i])
            b -= 1
            
            for i in range(b-1,t-1,-1):
                oplist.append(matrix[i][l])
            l += 1
        return oplist
```



## Hash Table

Leetcode LInk: https://leetcode.com/tag/hash-table/







## Math

Leetcode Link: https://leetcode.com/tag/math/

